# ARM_NEON_CNN_纯汇编编程_MNN 

[参考1](https://blog.csdn.net/jxt1234and2010/article/details/104012746)

纯汇编开发，优化策略相应的简单很多，基本上**循环展开、指令重排**之后，就有立竿见影的效果。

> 基本流程

1.梳理代码，设计实现方案，提炼出核心的运算部分，先用C实现一遍，保证正确;

2.32位汇编代码初步实现，保证功能正确;

3.汇编代码优化：这一步优化只做循环展开和指令重排，如果有更好的计算方案，先退回 C 重新写;

4.64位的也支持一下：替换一下寄存器名和指令名（可以写脚本完成），然后微调一下函数前后读参数、入出栈与返回的地方（可选）64位的进一步优化一下，毕竟寄存器多了一倍;

## Procedure Call Standard【函数调用标准】

### ARM 32(v7a)

> 通用寄存器 32bit  r0 r1 ... r15     

传参数用: r0 r1 r2 r3  用完要恢复(进栈保存后出栈): r4 r5 ... r11

随便使用: r0 r1 r2 r3, r12  不能使用(谨慎使用): r13 r14  r15 

> 向量寄存器128bit  q0 q1 ... q15  可以64bit形式使用 即 d0 d1 d2 d3 ... d30 d31

用完要恢复(进栈保存后出栈): q4 q5 q6 q7

随便使用: q0 q1 q2 q3, q8 q9 ... q15

用完恢复是指相应的寄存器在函数返回前必须恢复进入时的值，比如我们要在代码中用 q4，就必须在函数前写一句
```c 
vpush {q4} // 进栈保存 保护
```
函数返回前写一句：
```c
vpop {q4}  // 出栈恢复
```

### ARM 64(v8)


> 通用寄存器 64bit  x0 x1 ... x31 可以32bit形式使用  w0 w1 ... w31 使用低32位

传参数用: x0-x7  用完要恢复(进栈保存后出栈): x19-x28

随便使用: x0-x15  不能使用(谨慎使用): x16 x17 x18, x29 x30 x31

> 向量寄存器128bit  v0 v1 ... v31 

可以另外四种形式使用： **64位:d   32位:s  16位:h   8位:b**

传参数用: 浮点数据传到 v0 v1

用完要恢复(进栈保存后出栈): v8-v15

随便使用:  v0-v7  v16-v31

值得注意的是，arm64 的传参为浮点时，会传到 v0.s[0], v0.s[1] …… 而非通用寄存器，这个很坑，建议不要用浮点传参

